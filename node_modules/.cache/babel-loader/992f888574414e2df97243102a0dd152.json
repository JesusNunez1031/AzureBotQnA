{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nimport { Keys, classNames, dispatchEvent } from '@progress/kendo-react-common';\nimport * as PropTypes from 'prop-types';\nimport * as React from 'react';\nimport { convertMsgsToViewItems } from './../ViewItem';\nimport ActionGroup from './ActionGroup';\nimport AttachmentGroup from './AttachmentGroup';\nimport DateMarker from './DateMarker';\nimport MessageGroup from './MessageGroup';\nimport NewMessage from './NewMessage';\n/**\n * Represents the [KendoReact Chat component]({% slug overview_convui %}).\n */\n\nvar Chat =\n/** @class */\nfunction (_super) {\n  __extends(Chat, _super);\n\n  function Chat(props) {\n    var _this = _super.call(this, props) || this;\n\n    _this.onFocus = function () {\n      clearTimeout(_this.timeoutIdForChatLosingFocus);\n\n      _this.selectLastViewItemWhenNoCurrentSelection();\n    };\n\n    _this.onBlur = function () {\n      // This is a hacky solution to clear the selection when the focus is lost\n      // in favor of an element outside the Chat.\n      // https://medium.com/@jessebeach/dealing-with-focus-and-blur-in-a-composite-widget-in-react-90d3c3b49a9b\n      _this.timeoutIdForChatLosingFocus = setTimeout(function () {\n        _this.setState({\n          selectedItemIndex: null\n        });\n      }, 0);\n    };\n\n    _this.onSelectionRequested = function (clickedItemIndex) {\n      _this.setState({\n        selectedItemIndex: clickedItemIndex\n      });\n    };\n\n    _this.onKeyDown = function (event) {\n      var newSelectedItemIndex = null;\n      var currentSelectedItemIndex = _this.state.selectedItemIndex !== null ? _this.state.selectedItemIndex : _this.viewItems.lastSelectionIndex;\n\n      if (event.keyCode === Keys.up) {\n        if (currentSelectedItemIndex === null) {\n          newSelectedItemIndex = 0;\n        } else if (currentSelectedItemIndex > 0) {\n          newSelectedItemIndex = currentSelectedItemIndex - 1;\n        }\n      } else if (event.keyCode === Keys.down) {\n        if (currentSelectedItemIndex === null) {\n          newSelectedItemIndex = 0;\n        } else if (currentSelectedItemIndex < _this.viewItems.lastSelectionIndex) {\n          newSelectedItemIndex = currentSelectedItemIndex + 1;\n        }\n      }\n\n      if (newSelectedItemIndex !== null) {\n        _this.setState({\n          selectedItemIndex: newSelectedItemIndex\n        }); // Prevent the default behavior of moving of the scrollbar\n        // because scrolling is achieved through item focusing.\n\n\n        event.preventDefault();\n      }\n    };\n\n    _this.onMessageSend = function (message, event) {\n      dispatchEvent(_this.props.onMessageSend, event, _this, {\n        message: message\n      });\n    };\n\n    _this.onActionExecute = function (action, event) {\n      dispatchEvent(_this.props.onActionExecute, event, _this, {\n        action: action\n      });\n\n      if (!event.isDefaultPrevented()) {\n        switch (action.type) {\n          case 'reply':\n            _this.onMessageSend({\n              author: _this.props.user,\n              text: action.value,\n              timestamp: new Date()\n            }, event);\n\n            break;\n\n          case 'call':\n            window.open('tel:' + action.value);\n            break;\n\n          case 'openUrl':\n            window.open(action.value);\n            break;\n\n          default:\n            break;\n        }\n\n        _this.newMsgComp.focusInput();\n      }\n    };\n\n    _this.state = {\n      selectedItemIndex: null,\n      isFirstRender: true\n    };\n    return _this;\n  }\n  /**\n   * @hidden\n   */\n\n\n  Chat.prototype.render = function () {\n    var _this = this;\n\n    this.viewItems = this.getViewItemsFromMsgs(this.props.messages);\n    this.isDirectionRightToLeft = this.checkIsDirectionRightToLeft(this.props);\n    return React.createElement(\"div\", {\n      style: {\n        width: this.props.width\n      },\n      onKeyDown: this.onKeyDown,\n      className: this.getClassNames(),\n      ref: function (el) {\n        return _this.chatWrapperEl = el;\n      }\n    }, React.createElement(\"div\", {\n      className: \"k-message-list k-avatars\",\n      onBlur: this.onBlur,\n      onFocus: this.onFocus,\n      role: \"log\",\n      \"aria-live\": \"polite\",\n      ref: function (el) {\n        return _this.viewItemsWrapperEl = el;\n      }\n    }, React.createElement(\"div\", {\n      className: \"k-message-list-content\"\n    }, this.renderViewItems())), React.createElement(NewMessage, {\n      user: this.props.user,\n      onMessageSend: this.onMessageSend,\n      isDirectionRightToLeft: this.isDirectionRightToLeft,\n      ref: function (comp) {\n        return _this.newMsgComp = comp;\n      },\n      placeholder: this.props.placeholder\n    }));\n  };\n  /**\n   * @hidden\n   */\n\n\n  Chat.prototype.componentDidMount = function () {\n    var _this = this;\n\n    this.setState({\n      isFirstRender: false\n    }, function () {\n      // W/o setTimeout the scrolling does not manage to go to the bottom, some offset is left.\n      _this.nextTickId = setTimeout(function () {\n        return _this.scrollViewItemsToBottom();\n      }, 250);\n    });\n  };\n  /**\n   * @hidden\n   */\n\n\n  Chat.prototype.componentWillUnmount = function () {\n    clearTimeout(this.nextTickId);\n  };\n  /**\n   * @hidden\n   */\n\n\n  Chat.prototype.componentDidUpdate = function (prevProps) {\n    if (prevProps.messages.length !== this.props.messages.length) {\n      this.scrollViewItemsToBottom();\n    }\n  };\n\n  Chat.prototype.getClassNames = function () {\n    return classNames('k-widget', 'k-chat', this.props.className, {\n      'k-rtl': this.isDirectionRightToLeft\n    });\n  };\n\n  Chat.prototype.checkIsDirectionRightToLeft = function (props) {\n    var result = props.dir !== undefined ? props.dir === 'rtl' : this.chatWrapperEl && getComputedStyle(this.chatWrapperEl).direction === 'rtl';\n    return Boolean(result);\n  };\n\n  Chat.prototype.selectLastViewItemWhenNoCurrentSelection = function () {\n    if (this.state.selectedItemIndex === null) {\n      this.setState({\n        selectedItemIndex: this.viewItems.lastSelectionIndex\n      });\n    }\n  };\n\n  Chat.prototype.renderViewItems = function () {\n    var _this = this;\n\n    var lastViewItemIndex = this.viewItems.length - 1;\n    return this.viewItems.map(function (viewItem, index) {\n      if (viewItem.type === 'date-marker') {\n        return React.createElement(DateMarker, {\n          item: viewItem,\n          key: index\n        });\n      } else if (viewItem.type === 'message-group') {\n        return React.createElement(MessageGroup, {\n          group: viewItem,\n          itemTemplate: _this.props.messageTemplate,\n          attachmentTemplate: _this.props.attachmentTemplate,\n          user: _this.props.user,\n          selectedItemIndex: _this.state.selectedItemIndex,\n          onRequestSelection: _this.onSelectionRequested,\n          isLastGroup: index === lastViewItemIndex,\n          key: index\n        });\n      } else if (viewItem.type === 'attachment-group') {\n        return React.createElement(AttachmentGroup, {\n          group: viewItem,\n          itemTemplate: _this.props.attachmentTemplate,\n          onRequestSelection: _this.onSelectionRequested,\n          selected: viewItem.selectionIndex === _this.state.selectedItemIndex,\n          isLastGroup: index === lastViewItemIndex,\n          key: index\n        });\n      } else if (viewItem.type === 'action-group') {\n        return React.createElement(ActionGroup, {\n          group: viewItem,\n          onActionExecute: _this.onActionExecute,\n          onRequestSelection: _this.onSelectionRequested,\n          selected: viewItem.selectionIndex === _this.state.selectedItemIndex,\n          isLastGroup: index === lastViewItemIndex,\n          key: index\n        });\n      }\n    });\n  };\n\n  Chat.prototype.scrollViewItemsToBottom = function () {\n    if (this.viewItemsWrapperEl) {\n      this.viewItemsWrapperEl.scrollTop = this.viewItemsWrapperEl.scrollHeight - this.viewItemsWrapperEl.clientHeight;\n    }\n  };\n\n  Chat.prototype.getViewItemsFromMsgs = function (msgs) {\n    return msgs.length > 0 ? convertMsgsToViewItems(msgs) : [];\n  };\n  /**\n   * @hidden\n   */\n\n\n  Chat.propTypes = {\n    messages: PropTypes.arrayOf(PropTypes.object),\n    user: PropTypes.object,\n    messageTemplate: PropTypes.any,\n    attachmentTemplate: PropTypes.any,\n    width: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),\n    onMessageSend: PropTypes.func,\n    onActionExecute: PropTypes.func,\n    dir: PropTypes.string\n  };\n  /**\n   * @hidden\n   */\n\n  Chat.defaultProps = {\n    messages: []\n  };\n  return Chat;\n}(React.Component);\n\nexport { Chat };","map":null,"metadata":{},"sourceType":"module"}