{"ast":null,"code":"/*\n * The Original Code is Mozilla Universal charset detector code.\n *\n * The Initial Developer of the Original Code is\n * Netscape Communications Corporation.\n * Portions created by the Initial Developer are Copyright (C) 2001\n * the Initial Developer. All Rights Reserved.\n *\n * Contributor(s):\n *   Ant√≥nio Afonso (antonio.afonso gmail.com) - port to JavaScript\n *   Mark Pilgrim - port to Python\n *   Shy Shalom - original C code\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n * 02110-1301  USA\n */\n!function (jschardet) {\n  // This prober doesn't actually recognize a language or a charset.\n  // It is a helper prober for the use of the Hebrew model probers\n  ////// General ideas of the Hebrew charset recognition //////\n  //\n  // Four main charsets exist in Hebrew:\n  // \"ISO-8859-8\" - Visual Hebrew\n  // \"windows-1255\" - Logical Hebrew\n  // \"ISO-8859-8-I\" - Logical Hebrew\n  // \"x-mac-hebrew\" - ?? Logical Hebrew ??\n  //\n  // Both \"ISO\" charsets use a completely identical set of code points, whereas\n  // \"windows-1255\" and \"x-mac-hebrew\" are two different proper supersets of\n  // these code points. windows-1255 defines additional characters in the range\n  // 0x80-0x9F as some misc punctuation marks as well as some Hebrew-specific\n  // diacritics and additional 'Yiddish' ligature letters in the range 0xc0-0xd6.\n  // x-mac-hebrew defines similar additional code points but with a different\n  // mapping.\n  //\n  // As far as an average Hebrew text with no diacritics is concerned, all four\n  // charsets are identical with respect to code points. Meaning that for the\n  // main Hebrew alphabet, all four map the same values to all 27 Hebrew letters\n  // (including final letters).\n  //\n  // The dominant difference between these charsets is their directionality.\n  // \"Visual\" directionality means that the text is ordered as if the renderer is\n  // not aware of a BIDI rendering algorithm. The renderer sees the text and\n  // draws it from left to right. The text itself when ordered naturally is read\n  // backwards. A buffer of Visual Hebrew generally looks like so:\n  // \"[last word of first line spelled backwards] [whole line ordered backwards\n  // and spelled backwards] [first word of first line spelled backwards]\n  // [end of line] [last word of second line] ... etc' \"\n  // adding punctuation marks, numbers and English text to visual text is\n  // naturally also \"visual\" and from left to right.\n  //\n  // \"Logical\" directionality means the text is ordered \"naturally\" according to\n  // the order it is read. It is the responsibility of the renderer to display\n  // the text from right to left. A BIDI algorithm is used to place general\n  // punctuation marks, numbers and English text in the text.\n  //\n  // Texts in x-mac-hebrew are almost impossible to find on the Internet. From\n  // what little evidence I could find, it seems that its general directionality\n  // is Logical.\n  //\n  // To sum up all of the above, the Hebrew probing mechanism knows about two\n  // charsets:\n  // Visual Hebrew - \"ISO-8859-8\" - backwards text - Words and sentences are\n  //    backwards while line order is natural. For charset recognition purposes\n  //    the line order is unimportant (In fact, for this implementation, even\n  //    word order is unimportant).\n  // Logical Hebrew - \"windows-1255\" - normal, naturally ordered text.\n  //\n  // \"ISO-8859-8-I\" is a subset of windows-1255 and doesn't need to be\n  //    specifically identified.\n  // \"x-mac-hebrew\" is also identified as windows-1255. A text in x-mac-hebrew\n  //    that contain special punctuation marks or diacritics is displayed with\n  //    some unconverted characters showing as question marks. This problem might\n  //    be corrected using another model prober for x-mac-hebrew. Due to the fact\n  //    that x-mac-hebrew texts are so rare, writing another model prober isn't\n  //    worth the effort and performance hit.\n  //\n  //////// The Prober ////////\n  //\n  // The prober is divided between two SBCharSetProbers and a HebrewProber,\n  // all of which are managed, created, fed data, inquired and deleted by the\n  // SBCSGroupProber. The two SBCharSetProbers identify that the text is in\n  // fact some kind of Hebrew, Logical or Visual. The final decision about which\n  // one is it is made by the HebrewProber by combining final-letter scores\n  // with the scores of the two SBCharSetProbers to produce a final answer.\n  //\n  // The SBCSGroupProber is responsible for stripping the original text of HTML\n  // tags, English characters, numbers, low-ASCII punctuation characters, spaces\n  // and new lines. It reduces any sequence of such characters to a single space.\n  // The buffer fed to each prober in the SBCS group prober is pure text in\n  // high-ASCII.\n  // The two SBCharSetProbers (model probers) share the same language model:\n  // Win1255Model.\n  // The first SBCharSetProber uses the model normally as any other\n  // SBCharSetProber does, to recognize windows-1255, upon which this model was\n  // built. The second SBCharSetProber is told to make the pair-of-letter\n  // lookup in the language model backwards. This in practice exactly simulates\n  // a visual Hebrew model using the windows-1255 logical Hebrew model.\n  //\n  // The HebrewProber is not using any language model. All it does is look for\n  // final-letter evidence suggesting the text is either logical Hebrew or visual\n  // Hebrew. Disjointed from the model probers, the results of the HebrewProber\n  // alone are meaningless. HebrewProber always returns 0.00 as confidence\n  // since it never identifies a charset by itself. Instead, the pointer to the\n  // HebrewProber is passed to the model probers as a helper \"Name Prober\".\n  // When the Group prober receives a positive identification from any prober,\n  // it asks for the name of the charset identified. If the prober queried is a\n  // Hebrew model prober, the model prober forwards the call to the\n  // HebrewProber to make the final decision. In the HebrewProber, the\n  // decision is made according to the final-letters scores maintained and Both\n  // model probers scores. The answer is returned in the form of the name of the\n  // charset identified, either \"windows-1255\" or \"ISO-8859-8\".\n  jschardet.HebrewProber = function () {\n    jschardet.CharSetProber.apply(this); // windows-1255 / ISO-8859-8 code points of interest\n\n    var FINAL_KAF = '\\xea';\n    var NORMAL_KAF = '\\xeb';\n    var FINAL_MEM = '\\xed';\n    var NORMAL_MEM = '\\xee';\n    var FINAL_NUN = '\\xef';\n    var NORMAL_NUN = '\\xf0';\n    var FINAL_PE = '\\xf3';\n    var NORMAL_PE = '\\xf4';\n    var FINAL_TSADI = '\\xf5';\n    var NORMAL_TSADI = '\\xf6'; // Minimum Visual vs Logical final letter score difference.\n    // If the difference is below this, don't rely solely on the final letter score distance.\n\n    var MIN_FINAL_CHAR_DISTANCE = 5; // Minimum Visual vs Logical model score difference.\n    // If the difference is below this, don't rely at all on the model score distance.\n\n    var MIN_MODEL_DISTANCE = 0.01;\n    var VISUAL_HEBREW_NAME = \"ISO-8859-8\";\n    var LOGICAL_HEBREW_NAME = \"windows-1255\";\n    var self = this;\n\n    function init() {\n      self._mLogicalProber = null;\n      self._mVisualProber = null;\n      self.reset();\n    }\n\n    this.reset = function () {\n      this._mFinalCharLogicalScore = 0;\n      this._mFinalCharVisualScore = 0; // The two last characters seen in the previous buffer,\n      // mPrev and mBeforePrev are initialized to space in order to simulate a word\n      // delimiter at the beginning of the data\n\n      this._mPrev = \" \";\n      this._mBeforePrev = \" \"; // These probers are owned by the group prober.\n    };\n\n    this.setModelProbers = function (logicalProber, visualProber) {\n      this._mLogicalProber = logicalProber;\n      this._mVisualProber = visualProber;\n    };\n\n    this.isFinal = function (c) {\n      return [FINAL_KAF, FINAL_MEM, FINAL_NUN, FINAL_PE, FINAL_TSADI].indexOf(c) != -1;\n    };\n\n    this.isNonFinal = function (c) {\n      // The normal Tsadi is not a good Non-Final letter due to words like\n      // 'lechotet' (to chat) containing an apostrophe after the tsadi. This\n      // apostrophe is converted to a space in FilterWithoutEnglishLetters causing\n      // the Non-Final tsadi to appear at an end of a word even though this is not\n      // the case in the original text.\n      // The letters Pe and Kaf rarely display a related behavior of not being a\n      // good Non-Final letter. Words like 'Pop', 'Winamp' and 'Mubarak' for\n      // example legally end with a Non-Final Pe or Kaf. However, the benefit of\n      // these letters as Non-Final letters outweighs the damage since these words\n      // are quite rare.\n      return [NORMAL_KAF, NORMAL_MEM, NORMAL_NUN, NORMAL_PE].indexOf(c) != -1;\n    };\n\n    this.feed = function (aBuf) {\n      // Final letter analysis for logical-visual decision.\n      // Look for evidence that the received buffer is either logical Hebrew or\n      // visual Hebrew.\n      // The following cases are checked:\n      // 1) A word longer than 1 letter, ending with a final letter. This is an\n      //    indication that the text is laid out \"naturally\" since the final letter\n      //    really appears at the end. +1 for logical score.\n      // 2) A word longer than 1 letter, ending with a Non-Final letter. In normal\n      //    Hebrew, words ending with Kaf, Mem, Nun, Pe or Tsadi, should not end with\n      //    the Non-Final form of that letter. Exceptions to this rule are mentioned\n      //    above in isNonFinal(). This is an indication that the text is laid out\n      //    backwards. +1 for visual score\n      // 3) A word longer than 1 letter, starting with a final letter. Final letters\n      //    should not appear at the beginning of a word. This is an indication that\n      //    the text is laid out backwards. +1 for visual score.\n      //\n      // The visual score and logical score are accumulated throughout the text and\n      // are finally checked against each other in GetCharSetName().\n      // No checking for final letters in the middle of words is done since that case\n      // is not an indication for either Logical or Visual text.\n      //\n      // We automatically filter out all 7-bit characters (replace them with spaces)\n      // so the word boundary detection works properly. [MAP]\n      if (this.getState() == jschardet.Constants.notMe) {\n        // Both model probers say it's not them. No reason to continue.\n        return jschardet.Constants.notMe;\n      }\n\n      aBuf = this.filterHighBitOnly(aBuf);\n\n      for (var i = 0, cur; i < aBuf.length; i++) {\n        cur = aBuf[i];\n\n        if (cur == \" \") {\n          // We stand on a space - a word just ended\n          if (this._mBeforePrev != \" \") {\n            // next-to-last char was not a space so self._mPrev is not a 1 letter word\n            if (this.isFinal(this._mPrev)) {\n              // case (1) [-2:not space][-1:final letter][cur:space]\n              this._mFinalCharLogicalScore++;\n            } else if (this.isNonFinal(this._mPrev)) {\n              // case (2) [-2:not space][-1:Non-Final letter][cur:space]\n              this._mFinalCharVisualScore++;\n            }\n          }\n        } else {\n          // Not standing on a space\n          if (this._mBeforePrev == \" \" && this.isFinal(this._mPrev) && cur != \" \") {\n            // case (3) [-2:space][-1:final letter][cur:not space]\n            this._mFinalCharVisualScore++;\n          }\n        }\n\n        this._mBeforePrev = this._mPrev;\n        this._mPrev = cur;\n      } // Forever detecting, till the end or until both model probers return eNotMe (handled above)\n\n\n      return jschardet.Constants.detecting;\n    };\n\n    this.getCharsetName = function () {\n      // Make the decision: is it Logical or Visual?\n      // If the final letter score distance is dominant enough, rely on it.\n      var finalsub = this._mFinalCharLogicalScore - this._mFinalCharVisualScore;\n\n      if (finalsub >= MIN_FINAL_CHAR_DISTANCE) {\n        return LOGICAL_HEBREW_NAME;\n      }\n\n      if (finalsub <= -MIN_FINAL_CHAR_DISTANCE) {\n        return VISUAL_HEBREW_NAME;\n      } // It's not dominant enough, try to rely on the model scores instead.\n\n\n      var modelsub = this._mLogicalProber.getConfidence() - this._mVisualProber.getConfidence();\n\n      if (modelsub > MIN_MODEL_DISTANCE) {\n        return LOGICAL_HEBREW_NAME;\n      }\n\n      if (modelsub < -MIN_MODEL_DISTANCE) {\n        return VISUAL_HEBREW_NAME;\n      } // Still no good, back to final letter distance, maybe it'll save the day.\n\n\n      if (finalsub < 0) {\n        return VISUAL_HEBREW_NAME;\n      } // (finalsub > 0 - Logical) or (don't know what to do) default to Logical.\n\n\n      return LOGICAL_HEBREW_NAME;\n    };\n\n    this.getState = function () {\n      // Remain active as long as any of the model probers are active.\n      if (this._mLogicalProber.getState() == jschardet.Constants.notMe && this._mVisualProber.getState() == jschardet.Constants.notMe) {\n        return jschardet.Constants.notMe;\n      }\n\n      return jschardet.Constants.detecting;\n    };\n\n    init();\n  };\n\n  jschardet.HebrewProber.prototype = new jschardet.CharSetProber(); // https://developer.mozilla.org/En/Core_JavaScript_1.5_Reference/Objects/Array/IndexOf\n\n  if (!Array.prototype.indexOf) {\n    Array.prototype.indexOf = function (elt\n    /*, from*/\n    ) {\n      var len = this.length >>> 0;\n      var from = Number(arguments[1]) || 0;\n      from = from < 0 ? Math.ceil(from) : Math.floor(from);\n      if (from < 0) from += len;\n\n      for (; from < len; from++) {\n        if (from in this && this[from] === elt) return from;\n      }\n\n      return -1;\n    };\n  }\n}(require('./init'));","map":null,"metadata":{},"sourceType":"script"}