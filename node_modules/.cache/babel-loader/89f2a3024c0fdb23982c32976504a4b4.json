{"ast":null,"code":"/*\n * The Original Code is Mozilla Universal charset detector code.\n *\n * The Initial Developer of the Original Code is\n * Netscape Communications Corporation.\n * Portions created by the Initial Developer are Copyright (C) 2001\n * the Initial Developer. All Rights Reserved.\n *\n * Contributor(s):\n *   AntÃ³nio Afonso (antonio.afonso gmail.com) - port to JavaScript\n *   Mark Pilgrim - port to Python\n *   Shy Shalom - original C code\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n * 02110-1301  USA\n */\n\n/**\n * This is a port from the python port, version \"2.0.1\"\n */\n!function (jschardet) {\n  jschardet.UniversalDetector = function () {\n    var MINIMUM_THRESHOLD = jschardet.Constants.MINIMUM_THRESHOLD;\n    var _state = {\n      pureAscii: 0,\n      escAscii: 1,\n      highbyte: 2\n    };\n    var self = this;\n\n    function init() {\n      self._highBitDetector = /[\\x80-\\xFF]/;\n      self._escDetector = /(\\x1B|~\\{)/;\n      self._mEscCharsetProber = null;\n      self._mCharsetProbers = [];\n      self.reset();\n    }\n\n    this.reset = function () {\n      this.result = {\n        \"encoding\": null,\n        \"confidence\": 0.0\n      };\n      this.done = false;\n      this._mStart = true;\n      this._mGotData = false;\n      this._mInputState = _state.pureAscii;\n      this._mLastChar = \"\";\n      this._mBOM = \"\";\n\n      if (this._mEscCharsetProber) {\n        this._mEscCharsetProber.reset();\n      }\n\n      for (var i = 0, prober; prober = this._mCharsetProbers[i]; i++) {\n        prober.reset();\n      }\n    };\n\n    this.feed = function (aBuf) {\n      if (this.done) return;\n      var aLen = aBuf.length;\n      if (!aLen) return;\n\n      if (!this._mGotData) {\n        this._mBOM += aBuf; // If the data starts with BOM, we know it is UTF\n\n        if (this._mBOM.slice(0, 3) == \"\\xEF\\xBB\\xBF\") {\n          // EF BB BF  UTF-8 with BOM\n          this.result = {\n            \"encoding\": \"UTF-8\",\n            \"confidence\": 1.0\n          };\n        } else if (this._mBOM.slice(0, 4) == \"\\xFF\\xFE\\x00\\x00\") {\n          // FF FE 00 00  UTF-32, little-endian BOM\n          this.result = {\n            \"encoding\": \"UTF-32LE\",\n            \"confidence\": 1.0\n          };\n        } else if (this._mBOM.slice(0, 4) == \"\\x00\\x00\\xFE\\xFF\") {\n          // 00 00 FE FF  UTF-32, big-endian BOM\n          this.result = {\n            \"encoding\": \"UTF-32BE\",\n            \"confidence\": 1.0\n          };\n        } else if (this._mBOM.slice(0, 4) == \"\\xFE\\xFF\\x00\\x00\") {\n          // FE FF 00 00  UCS-4, unusual octet order BOM (3412)\n          this.result = {\n            \"encoding\": \"X-ISO-10646-UCS-4-3412\",\n            \"confidence\": 1.0\n          };\n        } else if (this._mBOM.slice(0, 4) == \"\\x00\\x00\\xFF\\xFE\") {\n          // 00 00 FF FE  UCS-4, unusual octet order BOM (2143)\n          this.result = {\n            \"encoding\": \"X-ISO-10646-UCS-4-2143\",\n            \"confidence\": 1.0\n          };\n        } else if (this._mBOM.slice(0, 2) == \"\\xFF\\xFE\") {\n          // FF FE  UTF-16, little endian BOM\n          this.result = {\n            \"encoding\": \"UTF-16LE\",\n            \"confidence\": 1.0\n          };\n        } else if (this._mBOM.slice(0, 2) == \"\\xFE\\xFF\") {\n          // FE FF  UTF-16, big endian BOM\n          this.result = {\n            \"encoding\": \"UTF-16BE\",\n            \"confidence\": 1.0\n          };\n        } // If we got to 4 chars without being able to detect a BOM we\n        // stop trying.\n\n\n        if (this._mBOM.length > 3) {\n          this._mGotData = true;\n        }\n      }\n\n      if (this.result.encoding && this.result.confidence > 0.0) {\n        this.done = true;\n        return;\n      }\n\n      if (this._mInputState == _state.pureAscii) {\n        if (this._highBitDetector.test(aBuf)) {\n          this._mInputState = _state.highbyte;\n        } else if (this._escDetector.test(this._mLastChar + aBuf)) {\n          this._mInputState = _state.escAscii;\n        }\n      }\n\n      this._mLastChar = aBuf.slice(-1);\n\n      if (this._mInputState == _state.escAscii) {\n        if (!this._mEscCharsetProber) {\n          this._mEscCharsetProber = new jschardet.EscCharSetProber();\n        }\n\n        if (this._mEscCharsetProber.feed(aBuf) == jschardet.Constants.foundIt) {\n          this.result = {\n            \"encoding\": this._mEscCharsetProber.getCharsetName(),\n            \"confidence\": this._mEscCharsetProber.getConfidence()\n          };\n          this.done = true;\n        }\n      } else if (this._mInputState == _state.highbyte) {\n        if (this._mCharsetProbers.length == 0) {\n          this._mCharsetProbers = [new jschardet.MBCSGroupProber(), new jschardet.SBCSGroupProber(), new jschardet.Latin1Prober()];\n        }\n\n        for (var i = 0, prober; prober = this._mCharsetProbers[i]; i++) {\n          if (prober.feed(aBuf) == jschardet.Constants.foundIt) {\n            this.result = {\n              \"encoding\": prober.getCharsetName(),\n              \"confidence\": prober.getConfidence()\n            };\n            this.done = true;\n            break;\n          }\n        }\n      }\n    };\n\n    this.close = function () {\n      if (this.done) return;\n\n      if (this._mBOM.length === 0) {\n        if (jschardet.Constants._debug) {\n          jschardet.log(\"no data received!\\n\");\n        }\n\n        return;\n      }\n\n      this.done = true;\n\n      if (this._mInputState == _state.pureAscii) {\n        if (jschardet.Constants._debug) {\n          jschardet.log(\"pure ascii\");\n        }\n\n        this.result = {\n          \"encoding\": \"ascii\",\n          \"confidence\": 1.0\n        };\n        return this.result;\n      }\n\n      if (this._mInputState == _state.highbyte) {\n        var proberConfidence = null;\n        var maxProberConfidence = 0.0;\n        var maxProber = null;\n\n        for (var i = 0, prober; prober = this._mCharsetProbers[i]; i++) {\n          if (!prober) continue;\n          proberConfidence = prober.getConfidence();\n\n          if (proberConfidence > maxProberConfidence) {\n            maxProberConfidence = proberConfidence;\n            maxProber = prober;\n          }\n\n          if (jschardet.Constants._debug) {\n            jschardet.log(prober.getCharsetName() + \" confidence \" + prober.getConfidence());\n          }\n        }\n\n        if (maxProber && maxProberConfidence > MINIMUM_THRESHOLD) {\n          this.result = {\n            \"encoding\": maxProber.getCharsetName(),\n            \"confidence\": maxProber.getConfidence()\n          };\n          return this.result;\n        }\n      }\n\n      if (jschardet.Constants._debug) {\n        jschardet.log(\"no probers hit minimum threshhold\\n\");\n\n        for (var i = 0, prober; prober = this._mCharsetProbers[i]; i++) {\n          if (!prober) continue;\n          jschardet.log(prober.getCharsetName() + \" confidence = \" + prober.getConfidence() + \"\\n\");\n        }\n      }\n    };\n\n    init();\n  };\n}(require('./init'));","map":null,"metadata":{},"sourceType":"script"}