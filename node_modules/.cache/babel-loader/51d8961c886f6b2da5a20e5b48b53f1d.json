{"ast":null,"code":"\"use strict\";\n/**\n * @module botframework-config\n */\n\n/**\n * Copyright(c) Microsoft Corporation.All rights reserved.\n * Licensed under the MIT License.\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst crypto = require(\"crypto\");\n/**\n * @private\n */\n\n\nfunction generateKey() {\n  // Generates 32 byte cryptographically strong pseudo-random data as a base64 encoded string\n  // https://nodejs.org/api/crypto.html#crypto_crypto_randombytes_size_callback\n  return crypto.randomBytes(32).toString('base64');\n}\n\nexports.generateKey = generateKey;\n/**\n * @private\n * Encrypt a string using standardized encyryption of AES256\n * @param plainText value to encrypt\n * @param secret secret to use\n */\n\nfunction encryptString(plainText, secret) {\n  if (!plainText || plainText.length === 0) {\n    return plainText;\n  }\n\n  if (!secret || secret.length === 0) {\n    throw new Error('you must pass a secret');\n  }\n\n  const keyBytes = Buffer.from(secret, 'base64'); // Generates 16 byte cryptographically strong pseudo-random data as IV\n  // https://nodejs.org/api/crypto.html#crypto_crypto_randombytes_size_callback\n\n  const ivBytes = crypto.randomBytes(16);\n  const ivText = ivBytes.toString('base64'); // encrypt using aes256 iv + key + plainText = encryptedText\n\n  const cipher = crypto.createCipheriv('aes-256-cbc', keyBytes, ivBytes);\n  let encryptedValue = cipher.update(plainText, 'utf8', 'base64');\n  encryptedValue += cipher.final('base64'); // store base64(ivBytes)!base64(encryptedValue)\n\n  return \"\".concat(ivText, \"!\").concat(encryptedValue);\n}\n\nexports.encryptString = encryptString;\n/**\n * @private\n * Decrypt a string using standardized encyryption of AES256\n * @param enryptedValue value to decrypt\n * @param secret secret to use\n */\n\nfunction decryptString(encryptedValue, secret) {\n  if (!encryptedValue || encryptedValue.length === 0) {\n    return encryptedValue;\n  }\n\n  if (!secret || secret.length === 0) {\n    throw new Error('you must pass a secret');\n  } // enrypted value = base64(ivBytes)!base64(encryptedValue)\n\n\n  const parts = encryptedValue.split('!');\n\n  if (parts.length !== 2) {\n    throw new Error('The encrypted value is not a valid format');\n  }\n\n  const ivText = parts[0];\n  const encryptedText = parts[1];\n  const ivBytes = Buffer.from(ivText, 'base64');\n  const keyBytes = Buffer.from(secret, 'base64');\n\n  if (ivBytes.length !== 16) {\n    throw new Error('The encrypted value is not a valid format');\n  }\n\n  if (keyBytes.length !== 32) {\n    throw new Error('The secret is not valid format');\n  } // decrypt using aes256 iv + key + encryptedText = decryptedText\n\n\n  const decipher = crypto.createDecipheriv('aes-256-cbc', keyBytes, ivBytes);\n  let value = decipher.update(encryptedText, 'base64', 'utf8');\n  value += decipher.final('utf8');\n  return value;\n}\n\nexports.decryptString = decryptString;\n/**\n * @private\n * @param encryptedValue\n * @param secret\n */\n\nfunction legacyDecrypt(encryptedValue, secret) {\n  // LEGACY for pre standardized SHA256 encryption, this uses some undocumented nodejs MD5 hash internally and is deprecated\n  const decipher = crypto.createDecipher('aes192', secret);\n  let value = decipher.update(encryptedValue, 'hex', 'utf8');\n  value += decipher.final('utf8');\n  return value;\n}\n\nexports.legacyDecrypt = legacyDecrypt;","map":null,"metadata":{},"sourceType":"script"}