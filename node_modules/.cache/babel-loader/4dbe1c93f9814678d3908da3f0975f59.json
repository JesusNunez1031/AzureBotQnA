{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n}); // Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nvar Enums = require(\"./enums\");\n\nvar Shared = require(\"./shared\");\n\nfunction generateUniqueId() {\n  return \"__ac-\" + Shared.UUID.generate();\n}\n\nexports.generateUniqueId = generateUniqueId;\n\nfunction getStringValue(obj, defaultValue) {\n  if (defaultValue === void 0) {\n    defaultValue = undefined;\n  }\n\n  return obj ? obj.toString() : defaultValue;\n}\n\nexports.getStringValue = getStringValue;\n\nfunction getValueOrDefault(obj, defaultValue) {\n  return obj ? obj : defaultValue;\n}\n\nexports.getValueOrDefault = getValueOrDefault;\n\nfunction isNullOrEmpty(value) {\n  return value === undefined || value === null || value === \"\";\n}\n\nexports.isNullOrEmpty = isNullOrEmpty;\n\nfunction appendChild(node, child) {\n  if (child != null && child != undefined) {\n    node.appendChild(child);\n  }\n}\n\nexports.appendChild = appendChild;\n\nfunction setProperty(target, propertyName, propertyValue, defaultValue) {\n  if (defaultValue === void 0) {\n    defaultValue = undefined;\n  }\n\n  if (propertyValue === null || propertyValue === undefined || propertyValue === defaultValue) {\n    delete target[propertyName];\n  } else {\n    target[propertyName] = propertyValue;\n  }\n}\n\nexports.setProperty = setProperty;\n\nfunction setEnumProperty(enumType, target, propertyName, propertyValue, defaultValue) {\n  if (defaultValue === void 0) {\n    defaultValue = undefined;\n  }\n\n  var targetValue = target[propertyName];\n  var canDeleteTarget = targetValue == undefined ? true : enumType[targetValue] !== undefined;\n\n  if (propertyValue == defaultValue) {\n    if (canDeleteTarget) {\n      delete target[propertyName];\n    }\n  } else {\n    if (propertyValue == undefined) {\n      if (canDeleteTarget) {\n        delete target[propertyName];\n      }\n    } else {\n      target[propertyName] = enumType[propertyValue];\n    }\n  }\n}\n\nexports.setEnumProperty = setEnumProperty;\n\nfunction getBoolValue(value, defaultValue) {\n  if (typeof value === \"boolean\") {\n    return value;\n  } else if (typeof value === \"string\") {\n    switch (value.toLowerCase()) {\n      case \"true\":\n        return true;\n\n      case \"false\":\n        return false;\n\n      default:\n        return defaultValue;\n    }\n  }\n\n  return defaultValue;\n}\n\nexports.getBoolValue = getBoolValue;\n\nfunction getEnumValue(targetEnum, name, defaultValue) {\n  if (isNullOrEmpty(name)) {\n    return defaultValue;\n  }\n\n  for (var key in targetEnum) {\n    var isValueProperty = parseInt(key, 10) >= 0;\n\n    if (isValueProperty) {\n      var value = targetEnum[key];\n\n      if (value && typeof value === \"string\") {\n        if (value.toLowerCase() === name.toLowerCase()) {\n          return parseInt(key, 10);\n        }\n      }\n    }\n  }\n\n  return defaultValue;\n}\n\nexports.getEnumValue = getEnumValue;\n\nfunction parseHostConfigEnum(targetEnum, value, defaultValue) {\n  if (typeof value === \"string\") {\n    return getEnumValue(targetEnum, value, defaultValue);\n  } else if (typeof value === \"number\") {\n    return getValueOrDefault(value, defaultValue);\n  } else {\n    return defaultValue;\n  }\n}\n\nexports.parseHostConfigEnum = parseHostConfigEnum;\n\nfunction renderSeparation(hostConfig, separationDefinition, orientation) {\n  if (separationDefinition.spacing > 0 || separationDefinition.lineThickness > 0) {\n    var separator = document.createElement(\"div\");\n    separator.className = hostConfig.makeCssClassName(\"ac-\" + (orientation == Enums.Orientation.Horizontal ? \"horizontal\" : \"vertical\") + \"-separator\");\n\n    if (orientation == Enums.Orientation.Horizontal) {\n      if (separationDefinition.lineThickness) {\n        separator.style.paddingTop = separationDefinition.spacing / 2 + \"px\";\n        separator.style.marginBottom = separationDefinition.spacing / 2 + \"px\";\n        separator.style.borderBottom = separationDefinition.lineThickness + \"px solid \" + stringToCssColor(separationDefinition.lineColor);\n      } else {\n        separator.style.height = separationDefinition.spacing + \"px\";\n      }\n    } else {\n      if (separationDefinition.lineThickness) {\n        separator.style.paddingLeft = separationDefinition.spacing / 2 + \"px\";\n        separator.style.marginRight = separationDefinition.spacing / 2 + \"px\";\n        separator.style.borderRight = separationDefinition.lineThickness + \"px solid \" + stringToCssColor(separationDefinition.lineColor);\n      } else {\n        separator.style.width = separationDefinition.spacing + \"px\";\n      }\n    }\n\n    separator.style.overflow = \"hidden\";\n    return separator;\n  } else {\n    return null;\n  }\n}\n\nexports.renderSeparation = renderSeparation;\n\nfunction stringToCssColor(color) {\n  var regEx = /#([0-9A-F]{2})([0-9A-F]{2})([0-9A-F]{2})([0-9A-F]{2})?/gi;\n  var matches = regEx.exec(color);\n\n  if (matches && matches[4]) {\n    var a = parseInt(matches[1], 16) / 255;\n    var r = parseInt(matches[2], 16);\n    var g = parseInt(matches[3], 16);\n    var b = parseInt(matches[4], 16);\n    return \"rgba(\" + r + \",\" + g + \",\" + b + \",\" + a + \")\";\n  } else {\n    return color;\n  }\n}\n\nexports.stringToCssColor = stringToCssColor;\n\nfunction truncate(element, maxHeight, lineHeight) {\n  var fits = function () {\n    // Allow a one pixel overflow to account for rounding differences\n    // between browsers\n    return maxHeight - element.scrollHeight >= -1.0;\n  };\n\n  if (fits()) return;\n  var fullText = element.innerHTML;\n\n  var truncateAt = function (idx) {\n    element.innerHTML = fullText.substring(0, idx) + '...';\n  };\n\n  var breakableIndices = findBreakableIndices(fullText);\n  var lo = 0;\n  var hi = breakableIndices.length;\n  var bestBreakIdx = 0; // Do a binary search for the longest string that fits\n\n  while (lo < hi) {\n    var mid = Math.floor((lo + hi) / 2);\n    truncateAt(breakableIndices[mid]);\n\n    if (fits()) {\n      bestBreakIdx = breakableIndices[mid];\n      lo = mid + 1;\n    } else {\n      hi = mid;\n    }\n  }\n\n  truncateAt(bestBreakIdx); // If we have extra room, try to expand the string letter by letter\n  // (covers the case where we have to break in the middle of a long word)\n\n  if (lineHeight && maxHeight - element.scrollHeight >= lineHeight - 1.0) {\n    var idx = findNextCharacter(fullText, bestBreakIdx);\n\n    while (idx < fullText.length) {\n      truncateAt(idx);\n\n      if (fits()) {\n        bestBreakIdx = idx;\n        idx = findNextCharacter(fullText, idx);\n      } else {\n        break;\n      }\n    }\n\n    truncateAt(bestBreakIdx);\n  }\n}\n\nexports.truncate = truncate;\n\nfunction findBreakableIndices(html) {\n  var results = [];\n  var idx = findNextCharacter(html, -1);\n\n  while (idx < html.length) {\n    if (html[idx] == ' ') {\n      results.push(idx);\n    }\n\n    idx = findNextCharacter(html, idx);\n  }\n\n  return results;\n}\n\nfunction findNextCharacter(html, currIdx) {\n  currIdx += 1; // If we found the start of an HTML tag, keep advancing until we get\n  // past it, so we don't end up truncating in the middle of the tag\n\n  while (currIdx < html.length && html[currIdx] == '<') {\n    while (currIdx < html.length && html[currIdx++] != '>');\n  }\n\n  return currIdx;\n}\n\nfunction getFitStatus(element, containerEnd) {\n  var start = element.offsetTop;\n  var end = start + element.clientHeight;\n\n  if (end <= containerEnd) {\n    return Enums.ContainerFitStatus.FullyInContainer;\n  } else if (start < containerEnd) {\n    return Enums.ContainerFitStatus.Overflowing;\n  } else {\n    return Enums.ContainerFitStatus.FullyOutOfContainer;\n  }\n}\n\nexports.getFitStatus = getFitStatus;","map":null,"metadata":{},"sourceType":"script"}