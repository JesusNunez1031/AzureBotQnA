{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * Copyright(c) Microsoft Corporation.All rights reserved.\n * Licensed under the MIT License.\n */\n\nconst fsx = require(\"fs-extra\");\n\nconst path = require(\"path\");\n\nconst process = require(\"process\");\n\nconst txtfile = require(\"read-text-file\");\n\nconst util = require(\"util\");\n\nconst uuid = require(\"uuid\");\n\nconst botConfigurationBase_1 = require(\"./botConfigurationBase\");\n\nconst encrypt = require(\"./encrypt\");\n\nconst schema_1 = require(\"./schema\"); // tslint:disable-next-line:no-var-requires no-require-imports\n\n\nconst exec = util.promisify(require('child_process').exec);\n/**\n * BotConfiguration represents configuration information for a bot.\n *\n * @remarks\n * It is typically loaded from a .bot file on disk. This class implements methods for encrypting\n * and manipulating the in-memory representation of the configuration.\n */\n\nclass BotConfiguration extends botConfigurationBase_1.BotConfigurationBase {\n  constructor() {\n    super(...arguments);\n    this.internal = {};\n  }\n  /**\n   * Returns a new BotConfiguration instance given a JSON based configuration.\n   * @param source JSON based configuration.\n   */\n\n\n  static fromJSON(source = {}) {\n    // tslint:disable-next-line:prefer-const\n    const services = source.services ? source.services.slice().map(botConfigurationBase_1.BotConfigurationBase.serviceFromJSON) : [];\n    const botConfig = new BotConfiguration();\n    Object.assign(botConfig, source); // back compat for secretKey rename\n\n    if (!botConfig.padlock && botConfig.secretKey) {\n      botConfig.padlock = botConfig.secretKey;\n      delete botConfig.secretKey;\n    }\n\n    botConfig.services = services;\n    botConfig.migrateData();\n    return botConfig;\n  }\n  /**\n   * Load the bot configuration by looking in a folder and loading the first .bot file in the\n   * folder.\n   * @param folder (Optional) folder to look for bot files. If not specified the current working directory is used.\n   * @param secret (Optional) secret used to decrypt the bot file.\n   */\n\n\n  static async loadBotFromFolder(folder, secret) {\n    folder = folder || process.cwd();\n    let files = await fsx.readdir(folder);\n    files = files.sort();\n\n    for (const file of files) {\n      if (path.extname(file) === '.bot') {\n        return await BotConfiguration.load(\"\".concat(folder, \"/\").concat(file), secret);\n      }\n    }\n\n    throw new Error(\"Error: no bot file found in \".concat(folder, \". Choose a different location or use msbot init to create a .bot file.\\\"\"));\n  }\n  /**\n   * Load the bot configuration by looking in a folder and loading the first .bot file in the\n   * folder. (blocking)\n   * @param folder (Optional) folder to look for bot files. If not specified the current working directory is used.\n   * @param secret (Optional) secret used to decrypt the bot file.\n   */\n\n\n  static loadBotFromFolderSync(folder, secret) {\n    folder = folder || process.cwd();\n    let files = fsx.readdirSync(folder);\n    files = files.sort();\n\n    for (const file of files) {\n      if (path.extname(file) === '.bot') {\n        return BotConfiguration.loadSync(\"\".concat(folder, \"/\").concat(file), secret);\n      }\n    }\n\n    throw new Error(\"Error: no bot file found in \".concat(folder, \". Choose a different location or use msbot init to create a .bot file.\\\"\"));\n  }\n  /**\n   * Load the configuration from a .bot file.\n   * @param botpath Path to bot file.\n   * @param secret (Optional) secret used to decrypt the bot file.\n   */\n\n\n  static async load(botpath, secret) {\n    const json = await txtfile.read(botpath);\n    const bot = BotConfiguration.internalLoad(json, secret);\n    bot.internal.location = botpath;\n    return bot;\n  }\n  /**\n   * Load the configuration from a .bot file. (blocking)\n   * @param botpath Path to bot file.\n   * @param secret (Optional) secret used to decrypt the bot file.\n   */\n\n\n  static loadSync(botpath, secret) {\n    const json = txtfile.readSync(botpath);\n    const bot = BotConfiguration.internalLoad(json, secret);\n    bot.internal.location = botpath;\n    return bot;\n  }\n  /**\n   * Generate a new key suitable for encrypting.\n   */\n\n\n  static generateKey() {\n    return encrypt.generateKey();\n  }\n\n  static internalLoad(json, secret) {\n    const bot = BotConfiguration.fromJSON(JSON.parse(json));\n    const hasSecret = !!bot.padlock;\n\n    if (hasSecret) {\n      bot.decrypt(secret);\n    }\n\n    return bot;\n  }\n  /**\n   * Save the configuration to a .bot file.\n   * @param botpath Path to bot file.\n   * @param secret (Optional) secret used to encrypt the bot file.\n   */\n\n\n  async saveAs(botpath, secret) {\n    if (!botpath) {\n      throw new Error(\"missing path\");\n    }\n\n    this.internal.location = botpath;\n    this.savePrep(secret);\n    const hasSecret = !!this.padlock;\n\n    if (hasSecret) {\n      this.encrypt(secret);\n    }\n\n    await fsx.writeJson(botpath, this.toJSON(), {\n      spaces: 4\n    });\n\n    if (hasSecret) {\n      this.decrypt(secret);\n    }\n  }\n  /**\n   * Save the configuration to a .bot file. (blocking)\n   * @param botpath Path to bot file.\n   * @param secret (Optional) secret used to encrypt the bot file.\n   */\n\n\n  saveAsSync(botpath, secret) {\n    if (!botpath) {\n      throw new Error(\"missing path\");\n    }\n\n    this.internal.location = botpath;\n    this.savePrep(secret);\n    const hasSecret = !!this.padlock;\n\n    if (hasSecret) {\n      this.encrypt(secret);\n    }\n\n    fsx.writeJsonSync(botpath, this.toJSON(), {\n      spaces: 4\n    });\n\n    if (hasSecret) {\n      this.decrypt(secret);\n    }\n  }\n  /**\n   * Save the file with secret.\n   * @param secret (Optional) secret used to encrypt the bot file.\n   */\n\n\n  async save(secret) {\n    return this.saveAs(this.internal.location, secret);\n  }\n  /**\n   * Save the file with secret. (blocking)\n   * @param secret (Optional) secret used to encrypt the bot file.\n   */\n\n\n  saveSync(secret) {\n    return this.saveAsSync(this.internal.location, secret);\n  }\n  /**\n   * Clear secret.\n   */\n\n\n  clearSecret() {\n    this.padlock = '';\n  }\n  /**\n   * Encrypt all values in the in memory config.\n   * @param secret Secret to encrypt.\n   */\n\n\n  encrypt(secret) {\n    this.validateSecret(secret);\n\n    for (const service of this.services) {\n      service.encrypt(secret, encrypt.encryptString);\n    }\n  }\n  /**\n   * Decrypt all values in the in memory config.\n   * @param secret Secret to decrypt.\n   */\n\n\n  decrypt(secret) {\n    try {\n      this.validateSecret(secret);\n\n      for (const connected_service of this.services) {\n        connected_service.decrypt(secret, encrypt.decryptString);\n      }\n    } catch (err) {\n      try {\n        // legacy decryption\n        this.padlock = encrypt.legacyDecrypt(this.padlock, secret);\n        this.clearSecret();\n        this.version = '2.0';\n        const encryptedProperties = {\n          abs: [],\n          endpoint: ['appPassword'],\n          luis: ['authoringKey', 'subscriptionKey'],\n          dispatch: ['authoringKey', 'subscriptionKey'],\n          file: [],\n          qna: ['subscriptionKey']\n        };\n\n        for (const service of this.services) {\n          for (const prop of encryptedProperties[service.type]) {\n            const val = service[prop];\n            service[prop] = encrypt.legacyDecrypt(val, secret);\n          }\n        } // assign new ids\n        // map old ids -> new Ids\n\n\n        const map = {};\n        const oldServices = this.services;\n        this.services = [];\n\n        for (const oldService of oldServices) {\n          // connecting causes new ids to be created\n          const newServiceId = this.connectService(oldService);\n          map[oldService.id] = newServiceId;\n        } // fix up dispatch serviceIds to new ids\n\n\n        for (const service of this.services) {\n          if (service.type === schema_1.ServiceTypes.Dispatch) {\n            const dispatch = service;\n\n            for (let i = 0; i < dispatch.serviceIds.length; i++) {\n              dispatch.serviceIds[i] = map[dispatch.serviceIds[i]];\n            }\n          }\n        }\n      } catch (err2) {\n        throw err;\n      }\n    }\n  }\n  /**\n   * Return the path that this config was loaded from.  .save() will save to this path.\n   */\n\n\n  getPath() {\n    return this.internal.location;\n  }\n  /**\n   * Make sure secret is correct by decrypting the secretKey with it.\n   * @param secret Secret to use.\n   */\n\n\n  validateSecret(secret) {\n    if (!secret) {\n      throw new Error('You are attempting to perform an operation which needs access to the secret and --secret is missing');\n    }\n\n    try {\n      if (!this.padlock || this.padlock.length === 0) {\n        // if no key, create a guid and enrypt that to use as secret validator\n        this.padlock = encrypt.encryptString(uuid(), secret);\n      } else {\n        // validate we can decrypt the padlock, this tells us we have the correct secret for the rest of the file.\n        encrypt.decryptString(this.padlock, secret);\n      }\n    } catch (ex) {\n      throw new Error('You are attempting to perform an operation which needs access to the secret and --secret is incorrect.');\n    }\n  }\n\n  savePrep(secret) {\n    if (!!secret) {\n      this.validateSecret(secret);\n    } // make sure that all dispatch serviceIds still match services that are in the bot\n\n\n    for (const service of this.services) {\n      if (service.type === schema_1.ServiceTypes.Dispatch) {\n        const dispatchService = service;\n        const validServices = [];\n\n        for (const dispatchServiceId of dispatchService.serviceIds) {\n          for (const this_service of this.services) {\n            if (this_service.id === dispatchServiceId) {\n              validServices.push(dispatchServiceId);\n            }\n          }\n        }\n\n        dispatchService.serviceIds = validServices;\n      }\n    }\n  }\n\n}\n\nexports.BotConfiguration = BotConfiguration; // Make sure the internal field is not included in JSON representation.\n\nObject.defineProperty(BotConfiguration.prototype, 'internal', {\n  enumerable: false,\n  writable: true\n});","map":null,"metadata":{},"sourceType":"script"}