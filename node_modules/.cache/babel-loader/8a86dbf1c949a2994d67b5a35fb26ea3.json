{"ast":null,"code":"/*\n * The Original Code is Mozilla Universal charset detector code.\n *\n * The Initial Developer of the Original Code is\n * Netscape Communications Corporation.\n * Portions created by the Initial Developer are Copyright (C) 2001\n * the Initial Developer. All Rights Reserved.\n *\n * Contributor(s):\n *   Ant√≥nio Afonso (antonio.afonso gmail.com) - port to JavaScript\n *   Mark Pilgrim - port to Python\n *   Shy Shalom - original C code\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n * 02110-1301  USA\n */\n!function (jschardet) {\n  jschardet.SingleByteCharSetProber = function (model, reversed, nameProber) {\n    jschardet.CharSetProber.apply(this);\n    var SAMPLE_SIZE = 64;\n    var SB_ENOUGH_REL_THRESHOLD = 1024;\n    var POSITIVE_SHORTCUT_THRESHOLD = 0.95;\n    var NEGATIVE_SHORTCUT_THRESHOLD = 0.05;\n    var SYMBOL_CAT_ORDER = 250;\n    var NUMBER_OF_SEQ_CAT = 4;\n    var POSITIVE_CAT = NUMBER_OF_SEQ_CAT - 1; //var NEGATIVE_CAT = 0;\n\n    var self = this;\n\n    function init(model, reversed, nameProber) {\n      self._mModel = model;\n      self._mReversed = reversed; // \"true\" if we need to reverse every pair in the model lookup\n\n      self._mNameProber = nameProber; // Optional auxiliary prober for name decision\n\n      self.reset();\n    }\n\n    this.reset = function () {\n      jschardet.SingleByteCharSetProber.prototype.reset.apply(this);\n      this._mLastOrder = 255; // char order of last character\n\n      this._mSeqCounters = [];\n\n      for (var i = 0; i < NUMBER_OF_SEQ_CAT; this._mSeqCounters[i++] = 0);\n\n      this._mTotalSeqs = 0;\n      this._mTotalChar = 0;\n      this._mFreqChar = 0; // characters that fall in our sampling range\n    };\n\n    this.getCharsetName = function () {\n      if (this._mNameProber) {\n        return this._mNameProber.getCharsetName();\n      } else {\n        return this._mModel.charsetName;\n      }\n    };\n\n    this.feed = function (aBuf) {\n      if (!this._mModel.keepEnglishLetter) {\n        aBuf = this.filterWithoutEnglishLetters(aBuf);\n      }\n\n      var aLen = aBuf.length;\n\n      if (!aLen) {\n        return this.getState();\n      }\n\n      for (var i = 0, c; i < aLen; i++) {\n        c = aBuf.charCodeAt(i);\n        var order = this._mModel.charToOrderMap[c];\n\n        if (order < SYMBOL_CAT_ORDER) {\n          this._mTotalChar++;\n        }\n\n        if (order < SAMPLE_SIZE) {\n          this._mFreqChar++;\n\n          if (this._mLastOrder < SAMPLE_SIZE) {\n            this._mTotalSeqs++;\n\n            if (!this._mReversed) {\n              this._mSeqCounters[this._mModel.precedenceMatrix[this._mLastOrder * SAMPLE_SIZE + order]]++;\n            } else {\n              // reverse the order of the letters in the lookup\n              this._mSeqCounters[this._mModel.precedenceMatrix[order * SAMPLE_SIZE + this._mLastOrder]]++;\n            }\n          }\n        }\n\n        this._mLastOrder = order;\n      }\n\n      if (this.getState() == jschardet.Constants.detecting) {\n        if (self._mTotalSeqs > SB_ENOUGH_REL_THRESHOLD) {\n          var cf = this.getConfidence();\n\n          if (cf > POSITIVE_SHORTCUT_THRESHOLD) {\n            if (jschardet.Constants._debug) {\n              jschardet.log(this._mModel.charsetName + \" confidence = \" + cf + \", we have a winner\\n\");\n            }\n          } else if (cf < NEGATIVE_SHORTCUT_THRESHOLD) {\n            if (jschardet.Constants._debug) {\n              jschardet.log(this._mModel.charsetName + \" confidence = \" + cf + \", below negative shortcut threshhold \" + NEGATIVE_SHORTCUT_THRESHOLD + \"\\n\");\n            }\n\n            this._mState = jschardet.Constants.notMe;\n          }\n        }\n      }\n\n      return this.getState();\n    };\n\n    this.getConfidence = function () {\n      var r = 0.01;\n\n      if (this._mTotalSeqs > 0) {\n        //jschardet.log(this._mSeqCounters[POSITIVE_CAT] + \" \" + this._mTotalSeqs + \" \" + this._mModel.mTypicalPositiveRatio);\n        r = 1.0 * this._mSeqCounters[POSITIVE_CAT] / this._mTotalSeqs / this._mModel.mTypicalPositiveRatio; //jschardet.log(r + \" \" + this._mFreqChar + \" \" + this._mTotalChar);\n\n        r *= this._mFreqChar / this._mTotalChar;\n\n        if (r >= 1.0) {\n          r = 0.99;\n        }\n      }\n\n      return r;\n    };\n\n    reversed = reversed !== undefined ? reversed : false;\n    nameProber = nameProber !== undefined ? nameProber : null;\n    init(model, reversed, nameProber);\n  };\n\n  jschardet.SingleByteCharSetProber.prototype = new jschardet.CharSetProber();\n}(require('./init'));","map":null,"metadata":{},"sourceType":"script"}